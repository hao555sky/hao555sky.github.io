[{"title":"Fragment 初探(一)","date":"2017-04-20T07:33:10.000Z","path":"2017/04/20/Fragment-初探-一/","text":"概述最近写项目的时候, 用到了fragment, 就想着系统学习一下,实现完还要整理下,毕竟技术这种东西,稍微时间长点就会忘记. 设计原理Android 在 Android 3.0（API 级别 11）中引入了片段，主要是为了给大屏幕（如平板电脑）上更加动态和灵活的 UI 设计提供支持。由于平板电脑的屏幕比手机屏幕大得多，因此可用于组合和交换 UI 组件的空间更大。利用片段实现此类设计时，您无需管理对视图层次结构的复杂更改。 通过将 Activity 布局分成片段，您可以在运行时修改 Activity 的外观，并在由 Activity 管理的返回栈中保留这些更改。 您应该将每个片段都设计为可重复使用的模块化 Activity 组件。也就是说，由于每个片段都会通过各自的生命周期回调来定义其自己的布局和行为，您可以将一个片段加入多个 Activity，因此，您应该采用可复用式设计，避免直接从某个片段直接操纵另一个片段。 这特别重要，因为模块化片段让您可以通过更改片段的组合方式来适应不同的屏幕尺寸。 在设计可同时支持平板电脑和手机的应用时，您可以在不同的布局配置中重复使用您的片段，以根据可用的屏幕空间优化用户体验。 例如，在手机上，如果不能在同一 Activity 内储存多个片段，可能必须利用单独片段来实现单窗格 UI。 例如 — 仍然以新闻应用为例 — 在平板电脑尺寸的设备上运行时，该应用可以在 Activity A 中嵌入两个片段。 不过，在手机尺寸的屏幕上，没有足以储存两个片段的空间，因此Activity A 只包括用于显示文章列表的片段，当用户选择文章时，它会启动Activity B，其中包括用于阅读文章的第二个片段。 因此，应用可通过重复使用不同组合的片段来同时支持平板电脑和手机，如图 1 所示。 Fragment生命周期Fragment生命周期和其与Activity比较 左边是fragment的生命周期, 右边是于Activity的比较 Fragment的生命周期方法 onAttach() : fragment于activity关联时调用 onCreate() : 系统创建Fragment所调用的方法, 注意该方法调用的时候,activity还在创建中.因此,activity中的相关视图结构还未被创建完成.如果想使用activity中的某些资源,要在onActivityCreated中获取. onCreateView() : 系统会在首次绘制fragment用户界面时调用此方法, 期望返回的view是fragment的布局视图, 也可以返回null 绘制方法是1234public View onCreateView (LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)&#123; View view = inflate.inflate(R.layout.fragment1, container, false); return view;&#125; 关于inflater方法我还有很多不理解的地方,以后会继续学习整理 onActivityCreated() : 表明activity已经完成了自身的onCreate()方法, 即Activity已经创建完成, activity的资源也已经全部可用. onStart() : 调用这个方法时,就表明Fragment对用户可见了, fragment的onStart是与Activity的onStart绑定的 onResume() : 与Activity的onResume类似, 调用这个方法时,表明fragment对用户可见, 当然fragment的onResume方法时基于Activity 的onResume方法的. 当onResume方法结束后,就可以与用户交互了 onPause() : 与Activity的onPause绑定,并且作用也是类似 onStop() : 与Activity的onStop绑定, 并且类似,表明fragment不在对用户可见 onDestroyView() : 当之前在onCreateView中创建的视图与fragment分离时调用, 如果下一次fragment想展示,就会创建一个新的视图, 该方法在onStop之后, onDestroy之前调用.无论onCreateView是否返回非空视图,都会调用该方法. 它会在视图状态保存后, 在它被父视图移除之前被调用 onDestroy() : 当这个fragment不再使用时调用. onDetach() : 取消fragment与activity的关联, 调用完后,不再拥有视图层次结构,资源也都将被释放. Fragment的使用静态方式静态方式添加就是在布局文件中添加fragment新建一个项目LearnFragment, 添加一个布局first_fragment.xml12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#009688\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:text=\"This is first fragment\" android:gravity=\"center\"/&gt;&lt;/LinearLayout&gt; 然后创建绘制该视图的java类123456789101112131415161718192021222324package com.example.hao.learnfragment.fragments;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.example.hao.learnfragment.R;/** * Created by hao on 17-4-20. */public class FirstFragment extends Fragment &#123; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.first_fragment, container, false); return view; &#125;&#125; 如法炮制,再创建second_fragment.xml和SecondFragment类, 然后修改MainActivity的布局文件activity_main,xml文件123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;fragment android:id=\"@+id/id_first_fragment\" android:name=\"com.example.hao.learnfragment.fragments.FirstFragment\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" tools:layout=\"@layout/first_fragment\" /&gt; &lt;fragment android:id=\"@+id/id_second_fragment\" android:name=\"com.example.hao.learnfragment.fragments.SecondFragment\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" tools:layout=\"@layout/second_fragment\" /&gt;&lt;/LinearLayout&gt; 因为我们使用的时v4下的Fragment, 所以MainActivity应该继承v4的FragmentActivity, 但是,API22之后就强制使用AppCompatActivity类,而该类已经继承了FragmentActivity, 故对于MainActivity不需要修改 感受下效果图 动态添加当然我们也可以通过动态添加的方式在代码中添加fragment, 这样做的好处是能够在Activity运行期间随时将fragment添加到Activity布局中;如果想在Activity中执行对fragment的操作,比如添加,移除或替换等, 可以分为几个步骤 获取FragmentManager实例, v4包中的获取方法通过getSupportFragmentManager方法 开启事务, 通过FragmentManager实例的beginTransaction方法 向事务中添加容器id和fragment 调用commit方法使更改生效 动态添加代码为12345FragmentManager fragmentManager = getSupportFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();ExampleFragment fragment = new ExampleFragment();fragmentTransaction.add(R.id.fragment_container, fragment);fragmentTransaction.commit(); 还是修改上面的例子, activity_main.xml12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;Button android:id=\"@+id/id_button_first_fragment\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"First Fragment\"/&gt; &lt;Button android:id=\"@+id/id_button_second_fragment\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Second Fragment\"/&gt; &lt;FrameLayout android:id=\"@+id/frame_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/LinearLayout&gt; 然后再修改下MainActivity中的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.example.hao.learnfragment;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentTransaction;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import com.example.hao.learnfragment.fragments.FirstFragment;import com.example.hao.learnfragment.fragments.SecondFragment;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button firstFragment = (Button)findViewById(R.id.id_button_first_fragment); firstFragment.setOnClickListener(this); Button secondFragment = (Button)findViewById(R.id.id_button_second_fragment); secondFragment.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); switch (v.getId())&#123; case R.id.id_button_first_fragment: Fragment firstFragment = new FirstFragment(); fragmentTransaction.add(R.id.frame_layout, firstFragment); break; case R.id.id_button_second_fragment: SecondFragment secondFragment = new SecondFragment(); fragmentTransaction.add(R.id.frame_layout, secondFragment); break; default: &#125; fragmentTransaction.commit(); &#125;&#125; 展示图 后记本部分主要记录了Fragment的设计原理,生命周期,以及基本使用方法, 还有很多关于Fragment的知识并没有说到,希望自己能够多加练习关于Fragment的使用, 也期待能够学习后续的知识,继续整理,前进.","tags":[]},{"title":"Android 自定义View (一)","date":"2017-02-21T03:42:13.000Z","path":"2017/02/21/Android-自定义View-一/","text":"Android 自定义View（一）##概述Android框架中创建了许多可供开发者调用的view，这些view能够与用户交互并且展示多样的数据。但是，当你的应用更加独特复杂的时候，内部创建的view可能已经无法满足你的需要。这时候就需要自己创建所需的view了。 那么如何创建自定义view呢? 哈哈， 看官别急，请听我慢慢道来。 View绘制流程 Android中View 的绘制过程包括三个最重要的方法，即onMeasure、onLayout和onDraw方法。在此不着重讲。 ##自定义View流程 自定义属性 扩展View 类或者扩展 View的某子类，例如Button 在自定义View中获取自定义的属性 重写onDraw()方法 自定义属性Android中内建的View都是可以通过XML元素控制展现的，所以一个良好的自定义View也要能通过XML构建。 在res/value/目录下创建attrs.xml文件 首先在&lt;declare-styleable&gt;资源元素中定义自定义的属性 在XMl文件中指定元素的值 运行中获取元素值 在自定义View中应用获取的元素值 1234567&lt;resources&gt; &lt;declare-styleable name=\"AlarmClockView\"&gt; &lt;attr name=\"ACVCircle_radius\" format=\"dimension\" /&gt; &lt;attr name=\"ACVCircle_color\" format=\"color\" /&gt; &lt;attr name=\"ACVCircle_change_color\" format=\"color\" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 本文件定义了圆的半径，颜色以及更改颜色三个属性，format是属性的取值类型， 这三个属性属于AlarmClockView类型实体，也就是说一般用该名字作为扩展View类的类名。 当我们定义了自定义属性后，就要在布局文件中应用他们了。应用时，自定义属性与内建属性没区别，唯一的不同之处在于不同的命名空间。自定义属性的命名空间时http://schemas.android.com/apk/res/[your package name] 123456789101112131415161718192021222324252627282930313233343536&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;com.example.youmiclock.AlarmClockView android:id=\"@+id/alarm_clock_view\" android:layout_width=\"300dp\" android:layout_height=\"300dp\" android:layout_centerHorizontal=\"true\" app:ACVCircle_radius=\"50dp\" app:ACVCircle_color=\"#FFD6D6D6\" app:ACVCircle_change_color=\"#26a69a\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"中国标准时间\" android:layout_centerHorizontal=\"true\" android:layout_below=\"@id/alarm_clock_view\" android:layout_marginTop=\"-30dp\"/&gt; &lt;/RelativeLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;/LinearLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 这里明明空间用的xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;是因为在Gradle工程中，工具会找到最正确的命名空间，不要硬编码自己的命名空间 ###应用自定义属性创建一个类继承于View或其子类，然后在构造方法中获取自定义属性.官方文档写到，虽然XML标签被传递到了AttributeSet 对象中，我们可以从中取得其值，但是这种方式有缺陷，所以我们要将AttributeSet传递到obtainStyledAttributes()中，该方法返回一个TypeArray对象。123456789101112131415161718public AlarmClockView(Context context) &#123; super(context); initPaint();&#125;public AlarmClockView(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.AlarmClockView); try &#123; circleRadius = typedArray.getDimensionPixelSize(R.styleable.AlarmClockView_ACVCircle_radius, 50); circleColor = typedArray.getColor(R.styleable.AlarmClockView_ACVCircle_color, Color.parseColor(\"#cfd8dc\")); circleChangeColor = typedArray.getColor(R.styleable.AlarmClockView_ACVCircle_change_color, Color.BLACK); &#125;finally &#123; typedArray.recycle(); &#125; initPaint();&#125; 记得回收TypeArray对象 View的构造函数有四中重载方式， 1234public void AlarmClockView(Context context) &#123;&#125;public void AlarmClockView(Context context, AttributeSet attrs) &#123;&#125;public void AlarmClockView(Context context, AttributeSet attrs, int defStyleAttr) &#123;&#125;public void AlarmClockView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;&#125; 四个参数的狗仔函数在API21时才添加，暂时不考虑三个参数的第三个参数一般不用，也暂时不考虑故只剩下一个参数和两个参数的构造函数以下方法调用的是一个参数的构造函数： 12//在Avtivity中AlarmClockView view = new AlarmClockView(this); 以下方法调用的是两个参数的构造函数： 12345678910//在layout文件中 - 格式为： 包名.View名 &lt;com.example.youmiclock.AlarmClockView android:id=\"@+id/alarm_clock_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerHorizontal=\"true\" app:ACVCircle_radius=\"100dp\" app:ACVCircle_color=\"#FFD6D6D6\" app:ACVCircle_change_color=\"#26a69a\" android:background=\"#000000\"/&gt; 现在的效果是， 黑色背景是为了突出尺寸 onMeasure()那么问题来了，我们在xml文件中已经指定了宽高，为什么还要在自定义View中再次测量设置么？因为View的大小不仅由自身决定，同事也会收到父控件的影响，为了能更好的适应各种情况，一般需要自己测量。 MeasureSpec共有三种测量模式| 模式名称 | 二进制数值 | 描述 || :———–| —————:| :—–:|| UNSPECIFIED | 00 |默认值，父控件没有给子view任何限制，子View可以设置为任意大小|| EXACTLY | 01 | 表示父控件已经确切的指定了子View的大小|| AT_MOST | 10 | 表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小| 如果对View的宽高进行修改了，不要调用super.onMeasure(widthMeasureSpec,heightMeasureSpec);要调用setMeasuredDimension(widthsize,heightsize); 这个函数。 12345678910111213141516171819202122232425262728@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int width; int height; if(widthMode == MeasureSpec.EXACTLY)&#123; width = widthSize; &#125;else &#123; width = widthSize / 2; circleRadius = 80; oval.set(-80, -80, 80, 80); &#125; if(heightMode == MeasureSpec.EXACTLY)&#123; height = heightSize; &#125;else &#123; height = heightSize / 2; &#125; setMeasuredDimension(width, height);&#125; 现在的效果是， 可能不太美观，有需要的自己再调一下合适的尺寸。 按照流程来讲，下面就应该是布局咯，即onLayout， 本段内容后续补齐吧 onDraw到了最重要的部分咯，即绘制部分，使用的是Canvas绘图 12345678910@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Log.d(TAG, \"onDraw: \" + hour + \":\" + minute + \":\" + second); canvas.translate(getWidth()/ 2, getHeight()/ 2); canvas.drawCircle(0, 0, circleRadius, circlePaint); getDegree(); // canvas.drawRect(oval, radiusPaint); canvas.drawArc(oval, -90, secondDegree, false, radiusPaint);&#125; 效果图， 绿色线条会随着时间增加，一秒6度。看来我还是要先高搞清楚怎么制作动态图片。Crying。 总结好啦，本篇暂时记录到这里，关于后续的自定义View，我会继续学习，继续记录，加油。","tags":[{"name":"Android, View","slug":"Android-View","permalink":"http://hao555sky.cn/tags/Android-View/"}]},{"title":"Java IO流初探","date":"2017-01-11T08:11:34.000Z","path":"2017/01/11/Java-IO流初探/","text":"Java IO流 初探最近学习安卓，发现数据存储应用了Java的IO，想着本就不熟悉，故借此机会深入学习一番，争取变得更好。 流流（Stream）是一个抽象概念，指代数据在计算机中各部件的流动。部件可以是文件，网络，内存等。流具有方向性，程序使用输入流读取数据，使用输出流存写数据。也就是说如果数据从程序流向设备，即为输出流，反之为输入流。、 流的分类 根据处理数据的不同：字节流和字符流 数据流向不同： 输入流和输出流 操作功能不同：节点流 和 处理流节点流：用来从数据源读入数据或往目的地写出数据处理流：对数据执行某崇操作 字符流字符流处理的基本单元是Unicode编码的数据，便于对字符数据的操作，Reader和Writer是java.io包中所有字符流的父类，因他们都是抽象类，故应使用其子类创建实体对象。Reader和Writer的子类又可分为节点流和处理流。 Reader面向字符的输入流都继承于Reader 类名 功能 CharArrayReader 从字符数组读取的输入流 BufferedReader 缓冲输入字符流 PipedReader 管道输入字符流 InputStreamReader 字节向字符转换的输入流 FileReader 文件读取输入字符流 FilterReader 过滤输入字符流 StringReader 字符串读取输入字符流 LineNumberReader 附加行号输入字符流 PushbackReader 返回一个字符并把字符放回输入流 使用FileReader类读取文件FileReader 类是 Reader 子类 InputStreamReader 类的子类，因此 FileReader 类既可以使用Reader 类的方法也可以使用 InputStreamReader 类的方法来创建对象。本例使用字符串构造方法。12345FileReader fileReader = new FileReader(\"example.txt\");char str[] = new char[1000];int num = fileReader.read(str);String string = new String(str, 0, num);System.out.print(string); 使用BufferedReader类读取文件BufferedReader 类是用来读取缓冲区中的数据。使用时必须创建 FileReader 类对象，再以该对象为参数创建 BufferedReader 类的对象12FileReader fileReader = new FileReader(\"example.txt\");BufferedReader bufferedReader = new BufferedReader(fileReader); Writer面向字符的输出流都继承于Writer Writer类及其子类与Reader相似，故略过。 记得使用BufferedReader类是，要用flush()方法将缓冲区清空 字节流字节流以字节为传输单位，用来读写8位的数据，除了能够处理纯文本文件之外，还能用来处理二进制文件的数据。 InputStream类和OutputStream类是所有字节流的父类。 InputStream面向字节的输入流都是继承于InputStream类 类名 功能 FileInputStream 文件读取输入字节流 PipedInputStream 管道输入字节流 FilterInputStream 过滤输入流 ByteArrayInputStream 从字节数组读取的输入流 SequenceInputStream 两个或多个输入流的联合输入流，按顺序读取 ObjectInputStream 对象的输入流 LineNumberInputStream 附加行号输入流 DataInputStream 包含读取Java标准数据类型的输入流 BufferedInputStream 缓冲输入流 PushbackInputStream 返回一个字节并把字节放回输入流 OutputStream面向字节的输入流都是继承于OutputStream类 输出输入流文件输入输出流 FileInputStream 和 FileOutputStream 负责完成对本地磁盘文件的顺序输入输出操作。 实现图片文件的复制12345678FileInputStream fileInputStream = new FileInputStream(\"binary_file_copy.png\");FileOutputStream fileOutputStream = new FileOutputStream(\"binary_file_copy2.png\");byte[] bytes = new byte[fileInputStream.available()];fileInputStream.read(bytes);fileOutputStream.write(bytes);System.out.println(\"文件已被更名复制\");fileInputStream.close();fileOutputStream.close(); 目前对于流就整理到这里，关于本文中所用得例子都在本地存放，希望自己在迷糊时能够回顾下。关于IO 中File以及RandomAccessFile会在后续整理。","tags":[]},{"title":"流年 | 一个人的狂欢 12.22-12.31","date":"2016-12-31T14:14:07.000Z","path":"2016/12/31/流年-一个人的狂欢-12-18-12-31/","text":"时间从指缝中悄无声息的溜走了没有了风吹的蒲公英又能留下些什么 跨年夜 2016即将结束了没想到最后是猪头和虎大哥陪我吃了今年跨年饭味道也还不错呆呆地猪头和威猛的虎大哥只能看着我吃掉盘中的最后一个饺子就当是对远去得2016画上句号吧 再见20162016 经历了很多有欢笑也有泪水考研失恋毕业入学等等每一件都刻骨铭心却又都在模糊消散做了许多错事伤害了许多人也不过是人生得一处处旅程走的多了才发现曾经在乎的不一定会陪你走下去 仍记得曾凌晨三点和小伙伴们起床去图书馆占座夜晚十一点伴着月光回宿舍休息那时候最希望得就是一场沉醉无梦得睡眠以及一次酣畅淋漓得运动所幸努力了并且收获了很开心也很满足 一直不敢回想和她在一起的日子害怕重新面对记忆中的她无奈记忆的细节早就模糊不清唯能记起某些难忘的事情忘记是幸运还是悲哀呢一个人的生活已经持续一年了没有曾经厌恶的吵闹也没有曾经的欢笑一直以为一个人的生活会很难熬最后发现也没什么只是还会经常想起她想起微笑的样子很美望安好 结束了感情也结束了大学生涯曾经把酒言欢的大家如今也都各自奔天涯希望东校的柳叶影院随风飘也希望我们的樱花永不散 你好2017人嘛总是要向前看的新的一年到了也希望自己能够做些改变成为更好的自己 多吃水果 早睡早起虽然很难 多和朋友联络 多点耐心与家人 多看书最重要的希望能够想清楚想要的是什么并为之努力","tags":[{"name":"流年","slug":"流年","permalink":"http://hao555sky.cn/tags/流年/"}]},{"title":"流年 | 遇事多思量 12.18-12.21","date":"2016-12-21T04:52:21.000Z","path":"2016/12/21/流年-遇事多思量-12-11-12-17/","text":"纵有千言万语，却不知如何诉诸于笔端。奈何人世险恶，只叹自己遇事未三思 事情缘由也不想过多谈及，毕竟也非喜事，仅望自己能像古语所说，吃一堑长一智。生活，遇到有所影响心境的事情，都应该深刻印于脑海，或记录在文章中，以便自己能够增长对生活的感悟，对世事的认知。 自觉对人一直以诚相待，答应之事也尽我所能，虽然仍自私自利，但在可控之内，能尽量不在威胁他人利益时保证自己。但一直苦恼为人处世的方式，明明有些人最后得了益处，却也获得了所谓的好感。而我诚心待人，有时还伤害了自己，却仍旧未能皆大欢喜。社会很多人都推崇为人处世是一门学问，我也这样认为，但却一直觉得诚心待人为根本，看来还是太傻。人么？总是需要两幅面孔，适当时机适当变换。 感悟 做事三思而后行，事情都有利弊，考虑清楚 诚心待人要分人，并不是每个人都值得自己去交，更不是每个人都值得自己真诚待人。 遇到共同利益，要认真思量，不要做枪，也不用枪。","tags":[{"name":"流年","slug":"流年","permalink":"http://hao555sky.cn/tags/流年/"}]},{"title":"流年 | 孤独，报以沉默 12.06-12.10","date":"2016-12-10T13:15:05.000Z","path":"2016/12/10/流年-孤独，报以沉默-12-06-12-10/","text":"又一次莫名的想起了青岛的生活，说来可笑，原因很简单，想来想去，陌生的北京竟然没有一个能陪我一起逛超市的人。 双十二的今天，健身结束后，师兄讲某某超市打折，我原本就不是醉心学术的人，必定打算逛逛超市，是否购买东西是次要的，只不过想打发掉无聊的周末。想法是好的，却没有想到，身边根本就没有会陪我一起出去的人。 想来，周围的人还是极好的，只不过自己过于敏感，总是觉得不想麻烦别人，更不想在认为不太熟的情况下，做些自认为很熟的事情。人嘛，总是这样，当面对陌生的环境，陌生的人群中，在身体或者心里中，总会呈现出某种防御姿态。 想起青岛，只是因为青岛有挂念的人，难忘的事。每当夜深人静或者孤独脆弱时，总会怀念青岛的一幕幕，石老人海滩放肆尽兴的奔跑，香港东路愉快满足的烧烤，八大关美轮美奂的落叶，都会像石老人黄昏的潮水般一股脑的涌入脑海。虽然明明心里知道，过去发生的细节早已记不清楚，只不过当时的感觉甚是强烈，以至于现在想来，都能触摸到旧事的温度，扬起嘴角。 相信过去的时光也曾后悔，也曾抱怨，但经过岁月的流失，留存下来的都是对古人的怀念，对旧事的追忆。 愿我们都被这世界，这时光温柔相待。 记得当时年纪小 你爱谈天我爱笑并肩坐在桃树下 风在林梢鸟在叫不知怎样睡着了 梦里花落知多少","tags":[{"name":"流年","slug":"流年","permalink":"http://hao555sky.cn/tags/流年/"}]},{"title":"Service 初探","date":"2016-12-08T08:25:49.000Z","path":"2016/12/08/Service-初探/","text":"Service 初探[TOC] ServiceService 是一个在后台长时间运行并执行操作而不使用用户界面的应用组件。Service没有用户界面，摆明了就是不让用户操作，但是它怎么工作呢？原来Service可以由组件启动或者将组件绑定到Service，进而执行相关操作，并且这一切全都在后台进行。 Service 工作形式启动 启动方式: 应用组件调用startService()，Service即处于启动状态。 生命周期: Service 在后台无限期运行，即使启动服务的组件被销毁也不受影响。 存在形式: 启动的服务通常执行单一操作，且不会将结果返回给调用方。 通信方式: startService()传递的Intent 结束方式: 服务使用stopSelf() 或者由其他组件调用stopService()停止。 绑定 启动方式: 应用组件调用bindService()，Service即处于绑定状态。 生命周期: 多个组件可同时绑定到该服务，只有当所有的组件取消绑定后，服务才会被销毁。 存在形式: 通信方式: 绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果甚至是利用进程 间通信(IPC)跨进程执行这些操作。 结束方式: 取消该服务与所有客户端之间的绑定，系统便会销毁该服务 注意 服务也可以同时以两种方式运行，即它可以是启动服务(无限期运行)，也允许绑定。关键在于是否实现了回调方法: onStartCommand()（允许组件启动服务）和onBind()（允许绑定服务）。 服务默认在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。也就表明，若服务将执行某些耗时操作，则应创建新线程执行，可以让主线程专注于用户与Activity之间的交互。 如何创建Service创建Service的子类（或使用现有子类，例如IntentService）。重写一些关键的回调方法，要重写的回调方法包括 onStartCommand() 当另一个组件（如Activity）调用startService()启动服务时，系统调用此方法。若只想提供绑定，则无需实现此方法。 onBind() 当另一个组件调用bindService()与服务绑定时，系统调用此方法。在此方法的实现中，返回IBinder对象，供客户端与服务进行通信。如果不希望绑定，应返回null。 onCreate() 在每个service的生命周期中只会被调用一次，并且在onStartCommand()以及onBind()之前，故可在此方法中进行一些一次性的初始化工作。 onDestroy() 这是服务调用的最后一个方法。当这个方法被调用后，服务将不再使用且被销毁，故可在此方法中清理所有资源，比如线程、注册的侦听器等。 使用清单文件声明服务同其他组件一样，要在manifest文件中声明所有服务。即添加&lt;service&gt;元素作为&lt;application&gt;元素的子元素&lt;service&gt;元素包含众多属性，来定义一些特性。android:name 属性是唯一必须的属性，用于指定服务的类名android相关属性 1234567891011&lt;service android:description=\"string resource\" android:enabled=[\"true\" | \"false\"] android:exported=[\"true\" | \"false\"] android:icon=\"drawable resource\" android:isolatedProcess=[\"true\" | \"false\"] android:label=\"string resource\" android:name=\"string\" android:permission=\"string\" android:process=\"string\" &gt; . . . &lt;/service&gt; 注意 为了保证应用的安全性，尽量使用显示Intent启动或者绑定Service，且不要声明Intent filter. 尽量添加android:exported=false属性，确保服务仅适用你的应用。 创建启动服务一般来说，可以扩展两个类来创建启动服务: Service适用于所有服务的基类。扩展此类时，默认情况，服务将使用应用的主线程，会降低正在运行的所有Activity的性能。故必须创建一个用于执行所有服务工作的新线程。 IntentService这是 Service 的子类，它使用工作线程逐一处理所有启动请求。如果您不要求服务同时处理多个请求，这是最好的选择。 您只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的 Intent，使您能够执行后台工作。 扩展Service类12345678910111213141516171819202122232425262728public class CommonServiceDemo extends Service &#123; private static final String TAG = \"CommonServiceDemo\"; @Override public void onCreate()&#123; super.onCreate(); Log.d(TAG, \"onCreate\"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId)&#123; Log.d(TAG, \"onStartCommand\"); return super.onStartCommand(intent, flags, startId); &#125; @Nullable @Override public IBinder onBind(Intent intent)&#123; Log.d(TAG, \"onBind\"); return null; &#125; @Override public void onDestroy()&#123; Log.d(TAG, \"onDestroy\"); super.onDestroy(); &#125;&#125; Manifest文件&lt;service android:name=&quot;.ServiceDemo&quot; /&gt; 扩展IntentService类如果启动服务不需要同时处理多个请求（实际上，这种多线程情况可能很危险），所以使用IntentService类实现服务是最好的选择。IntentService操作: 创建默认的工作线程，用于在应用的主线程外执行传递给onStartCommand()的所有Intent 创建工作队列，用于将Intent逐一传递给onHandleIntent()实现，这样就不必担心多线程问题 处理完所有启动请求后停止服务，因此不必调用stopSelf() 提供onBind()的默认实现（返回null） 提供onStartCommand()的默认实现，可将Intent一次发送到工作队列和onHandleIntent()实现2zhixu实现一个构造函数和onHandleIntent()方法即可123456789101112131415public class HelloIntentService extends IntentService &#123; public HelloIntentService()&#123; super(\"HelloIntentService\"); &#125; @Override protected void onHandleIntent(Intent intent)&#123; try &#123; Thread.sleep(5000); &#125;catch (InterruptedException e)&#123; Thread.currentThread().interrupt(); &#125; &#125;&#125; 启动服务在Activity或者其他应用组建中，可通过Intent传递给startService()启动服务。Android 系统调用服务的 onStartCommand() 方法，并向其传递 Intent。（切勿直接调用 onStartCommand()。） 例如，显示Intent传递给startService，启动服务CommanServiceDemo12Intent intent = new Intent(MainActivity.this, CommonServiceDemo.class);startService(intent); 注意 如果服务尚未运行，则系统会先调用 onCreate()，然后再调用 onStartCommand()。 多个服务启动请求会导致多次对服务的 onStartCommand() 进行相应的调用。但是，要停止服务，只需一个服务停止请求（使用 stopSelf() 或 stopService()）即可。 创建绑定服务要创建绑定服务，必须实现onBind()方法，返回IBinder对象，作为客户端与服务通信的接口。 多个客户端可以同时绑定到服务。客户端完成与服务的交互后，会调用 unbindService() 取消绑定。一旦没有客户端绑定到该服务，系统就会销毁它。 绑定服务的实现比启动服务更加复杂，故放到下一篇博客 结语本篇博客主要讲解了service的一些基本知识，包括什么是service，service的类别，如果创建service，如何启动service，关于service中的绑定服务，生命周期，以及启动服务的扩展Service（执行多线程而不是通过工作队列处理启动请求），前台运行的相关知识还未讲解，故希望日后能都学习补全。","tags":[{"name":"Android","slug":"Android","permalink":"http://hao555sky.cn/tags/Android/"}]}]